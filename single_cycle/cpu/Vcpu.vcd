$version Generated by VerilatedVcd $end
$date Sun Dec  3 01:07:05 2023 $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire 32 H a0 [31:0] $end
  $var wire  1 F clk $end
  $var wire  1 G rst $end
  $scope module cpu $end
   $var wire 32 M ADDRESS_WIDTH [31:0] $end
   $var wire  8 8 ALUResult [7:0] $end
   $var wire  3 9 ALUctrl [2:0] $end
   $var wire  1 : ALUsrc $end
   $var wire 32 O CONTROL_WIDTH [31:0] $end
   $var wire 32 N DATA_WIDTH [31:0] $end
   $var wire  1 Q EQ $end
   $var wire 32 P IMM_WIDTH [31:0] $end
   $var wire 32 < ImmOp [31:0] $end
   $var wire 32 # Instr [31:0] $end
   $var wire  1 7 MemWrite $end
   $var wire  8 $ PC [7:0] $end
   $var wire  8 % PCPlus4 [7:0] $end
   $var wire  2 = PCsrc [1:0] $end
   $var wire  1 6 RegWrite $end
   $var wire  2 ; Resultsrc [1:0] $end
   $var wire  1 I Zero $end
   $var wire 32 H a0 [31:0] $end
   $var wire  1 F clk $end
   $var wire  1 G rst $end
   $scope module alu $end
    $var wire 32 > ALUResult_o [31:0] $end
    $var wire  3 9 ALUctrl_i [2:0] $end
    $var wire  1 : ALUsrc_i $end
    $var wire 32 O CONTROL_WIDTH [31:0] $end
    $var wire 32 N DATA_WIDTH [31:0] $end
    $var wire 32 < ImmOp_i [31:0] $end
    $var wire 32 # Instr_i [31:0] $end
    $var wire  1 7 MemWrite_i $end
    $var wire  1 & PCPlus4_i $end
    $var wire 32 K ReadData [31:0] $end
    $var wire  1 6 RegWrite_i $end
    $var wire  2 ; ResultSrc_i [1:0] $end
    $var wire 32 J Result_o [31:0] $end
    $var wire 32 ' SrcA [31:0] $end
    $var wire 32 ? SrcB [31:0] $end
    $var wire  1 I Zero_o $end
    $var wire 32 H a0 [31:0] $end
    $var wire  1 F clk $end
    $var wire 32 ( regOp2 [31:0] $end
    $scope module ALU $end
     $var wire 32 > ALUResult [31:0] $end
     $var wire  3 9 ALUctrl [2:0] $end
     $var wire 32 O CONTROL_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire 32 ' SrcA [31:0] $end
     $var wire 32 ? SrcB [31:0] $end
     $var wire  1 I Zero $end
    $upscope $end
    $scope module ALUMux $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire  1 : control $end
     $var wire 32 ( input0 [31:0] $end
     $var wire 32 < input1 [31:0] $end
     $var wire 32 ? out [31:0] $end
    $upscope $end
    $scope module data $end
     $var wire  8 8 A [7:0] $end
     $var wire 32 M ADDRESS_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire 32 K RD [31:0] $end
     $var wire 32 ( WD [31:0] $end
     $var wire  1 7 WE $end
     $var wire  1 F clk $end
    $upscope $end
    $scope module register $end
     $var wire  5 * A1 [4:0] $end
     $var wire  5 ) A2 [4:0] $end
     $var wire  5 + A3 [4:0] $end
     $var wire 32 M ADDRESS_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire 32 # Instr [31:0] $end
     $var wire 32 ' RD1 [31:0] $end
     $var wire 32 ( RD2 [31:0] $end
     $var wire 32 > WD3 [31:0] $end
     $var wire  1 6 WE3 $end
     $var wire 32 H a0 [31:0] $end
     $var wire  1 F clk $end
    $upscope $end
    $scope module resultMux $end
     $var wire 32 P CONTROL_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire  2 ; control [1:0] $end
     $var wire 32 K input0 [31:0] $end
     $var wire 32 > input1 [31:0] $end
     $var wire 32 , input2 [31:0] $end
     $var wire 32 R input3 [31:0] $end
     $var wire 32 J out [31:0] $end
    $upscope $end
   $upscope $end
   $scope module control $end
    $var wire 32 M ADDRESS_WIDTH [31:0] $end
    $var wire  3 9 ALUctrl_o [2:0] $end
    $var wire  1 : ALUsrc_o $end
    $var wire 32 O CONTROL_WIDTH [31:0] $end
    $var wire 32 N DATA_WIDTH [31:0] $end
    $var wire 32 P IMM_WIDTH [31:0] $end
    $var wire 32 < ImmOp_o [31:0] $end
    $var wire  2 @ ImmSrc [1:0] $end
    $var wire  1 7 MemWrite_o $end
    $var wire  8 $ PC_i [7:0] $end
    $var wire  2 = PCsrc_o [1:0] $end
    $var wire  1 6 RegWrite_o $end
    $var wire  2 ; Resultsrc_o [1:0] $end
    $var wire  1 I Zero_i $end
    $var wire 32 # instr_o [31:0] $end
    $scope module ControlUnit $end
     $var wire  3 9 ALUctrl_o [2:0] $end
     $var wire  1 : ALUsrc_o $end
     $var wire 32 O CONTROL_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire 32 P IMM_WIDTH [31:0] $end
     $var wire  2 @ ImmSrc_o [1:0] $end
     $var wire  1 7 MemWrite_o $end
     $var wire  2 = PCsrc_o [1:0] $end
     $var wire  1 6 RegWrite_o $end
     $var wire  2 ; Resultsrc_o [1:0] $end
     $var wire  1 I Zero_i $end
     $var wire  3 . funct3 [2:0] $end
     $var wire 32 # instr_i [31:0] $end
     $var wire  7 - opcode [6:0] $end
    $upscope $end
    $scope module InstrMem $end
     $var wire 32 M ADDRESS_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire 32 # Instr_o [31:0] $end
     $var wire  8 $ addr_i [7:0] $end
     $var wire  8 / rom_array0 [7:0] $end
     $var wire  8 0 rom_array1 [7:0] $end
     $var wire  8 1 rom_array2 [7:0] $end
     $var wire  8 2 rom_array3 [7:0] $end
    $upscope $end
    $scope module MySignExtend $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire 32 P IMM_WIDTH [31:0] $end
     $var wire 32 < ImmOp_o [31:0] $end
     $var wire  2 @ ImmSrc_i [1:0] $end
     $var wire 32 # instr_i [31:0] $end
    $upscope $end
   $upscope $end
   $scope module pc $end
    $var wire  1 A ALUResult_i $end
    $var wire 32 < ImmOp_i [31:0] $end
    $var wire 32 5 PC [31:0] $end
    $var wire 32 4 PCPlus4_o [31:0] $end
    $var wire 32 L PCTarget [31:0] $end
    $var wire  1 B PCsrc_i $end
    $var wire 32 N WIDTH [31:0] $end
    $var wire  1 F clk $end
    $var wire 32 C next_PC [31:0] $end
    $var wire 32 3 pc_out [31:0] $end
    $var wire  1 G rst $end
    $scope module pc_mux $end
     $var wire 32 P CONTROL_WIDTH [31:0] $end
     $var wire 32 N DATA_WIDTH [31:0] $end
     $var wire  2 D control [1:0] $end
     $var wire 32 4 input0 [31:0] $end
     $var wire 32 L input1 [31:0] $end
     $var wire 32 E input2 [31:0] $end
     $var wire 32 S input3 [31:0] $end
     $var wire 32 C out [31:0] $end
    $upscope $end
    $scope module pc_reg $end
     $var wire 32 N WIDTH [31:0] $end
     $var wire 32 3 another_pc [31:0] $end
     $var wire  1 F clk $end
     $var wire 32 C next_PC [31:0] $end
     $var wire 32 5 pc [31:0] $end
     $var wire  1 G rst $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b00000000000000000000000000000000 #
b00000000 $
b00000100 %
0&
b00000000000000000000000000000000 '
b00000000000000000000000000000000 (
b00000 )
b00000 *
b00000 +
b00000000000000000000000000000000 ,
b0000000 -
b000 .
b00000000 /
b00000000 0
b00000000 1
b00000000 2
b00000000000000000000000000000000 3
b00000000000000000000000000000100 4
b00000000000000000000000000000000 5
06
07
b00000000 8
b000 9
0:
b00 ;
b00000000000000000000000000000000 <
b00 =
b00000000000000000000000000000000 >
b00000000000000000000000000000000 ?
b00 @
0A
0B
b00000000000000000000000000000000 C
b00 D
b00000000000000000000000000000000 E
0F
0G
b00000000000000000000000000000000 H
1I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
b00000000000000000000000000000000 L
b00000000000000000000000000001000 M
b00000000000000000000000000100000 N
b00000000000000000000000000000011 O
b00000000000000000000000000000010 P
0Q
b00000000000000000000000000000000 R
b00000000000000000000000000000000 S
#2
b00001111111100000000001100010011 #
b11111 )
b00110 +
b0010011 -
b00010011 /
b00000011 0
b11110000 1
b00001111 2
16
b11111111 8
1:
b00000000000000000000000011111111 <
b00000000000000000000000011111111 >
b00000000000000000000000011111111 ?
b01 @
1A
b00000000000000000000000000000100 C
b00000000000000000000000000000001 E
0I
b00000000000000000000000011111111 L
#4
#6
#8
#10
#12
#14
#16
#18
