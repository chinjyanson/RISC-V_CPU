$version Generated by VerilatedVcd $end
$date Tue Dec  5 15:41:43 2023 $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire 32 = a0 [31:0] $end
  $var wire  1 ; clk $end
  $var wire  1 < rst $end
  $scope module cpu $end
   $var wire 32 B ADDRESS_WIDTH [31:0] $end
   $var wire  3 1 ALUctrl [2:0] $end
   $var wire  1 2 ALUsrc $end
   $var wire 32 D CONTROL_WIDTH [31:0] $end
   $var wire 32 C DATA_WIDTH [31:0] $end
   $var wire 32 E IMM_WIDTH [31:0] $end
   $var wire 32 4 ImmOp [31:0] $end
   $var wire 32 # Instr [31:0] $end
   $var wire  1 0 MemWrite $end
   $var wire  8 $ PC [7:0] $end
   $var wire 32 % PCPlus4 [31:0] $end
   $var wire  2 5 PCsrc [1:0] $end
   $var wire  1 / RegWrite $end
   $var wire 32 6 Result [31:0] $end
   $var wire  2 3 Resultsrc [1:0] $end
   $var wire  1 > Zero $end
   $var wire 32 = a0 [31:0] $end
   $var wire  1 ; clk $end
   $var wire  1 < rst $end
   $scope module alu $end
    $var wire 32 6 ALUResult_o [31:0] $end
    $var wire  3 1 ALUctrl_i [2:0] $end
    $var wire  1 2 ALUsrc_i $end
    $var wire 32 D CONTROL_WIDTH [31:0] $end
    $var wire 32 C DATA_WIDTH [31:0] $end
    $var wire 32 4 ImmOp_i [31:0] $end
    $var wire 32 # Instr_i [31:0] $end
    $var wire  1 0 MemWrite_i $end
    $var wire 32 % PCPlus4_i [31:0] $end
    $var wire 32 @ ReadData [31:0] $end
    $var wire  1 / RegWrite_i $end
    $var wire 32 ? Result [31:0] $end
    $var wire  2 3 ResultSrc_i [1:0] $end
    $var wire 32 & SrcA [31:0] $end
    $var wire 32 7 SrcB [31:0] $end
    $var wire  1 > Zero_o $end
    $var wire 32 = a0 [31:0] $end
    $var wire  1 ; clk $end
    $var wire 32 ' regOp2 [31:0] $end
    $scope module ALU $end
     $var wire 32 6 ALUResult [31:0] $end
     $var wire  3 1 ALUctrl [2:0] $end
     $var wire 32 D CONTROL_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire 32 & SrcA [31:0] $end
     $var wire 32 7 SrcB [31:0] $end
     $var wire  1 > Zero $end
    $upscope $end
    $scope module ALUMux $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire  1 2 control $end
     $var wire 32 ' input0 [31:0] $end
     $var wire 32 4 input1 [31:0] $end
     $var wire 32 7 out [31:0] $end
    $upscope $end
    $scope module data $end
     $var wire  8 8 A [7:0] $end
     $var wire 32 B ADDRESS_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire 32 @ RD [31:0] $end
     $var wire 32 ' WD [31:0] $end
     $var wire  1 0 WE $end
     $var wire  1 ; clk $end
    $upscope $end
    $scope module register $end
     $var wire  8 ) A1 [7:0] $end
     $var wire  8 ( A2 [7:0] $end
     $var wire  8 * A3 [7:0] $end
     $var wire 32 B ADDRESS_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire 32 # Instr [31:0] $end
     $var wire 32 & RD1 [31:0] $end
     $var wire 32 ' RD2 [31:0] $end
     $var wire 32 ? WD3 [31:0] $end
     $var wire  1 / WE3 $end
     $var wire 32 = a0 [31:0] $end
     $var wire  1 ; clk $end
    $upscope $end
    $scope module resultMux $end
     $var wire 32 E CONTROL_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire  2 3 control [1:0] $end
     $var wire 32 6 input0 [31:0] $end
     $var wire 32 @ input1 [31:0] $end
     $var wire 32 % input2 [31:0] $end
     $var wire 32 F input3 [31:0] $end
     $var wire 32 ? out [31:0] $end
    $upscope $end
   $upscope $end
   $scope module control $end
    $var wire 32 B ADDRESS_WIDTH [31:0] $end
    $var wire  3 1 ALUctrl_o [2:0] $end
    $var wire  1 2 ALUsrc_o $end
    $var wire 32 D CONTROL_WIDTH [31:0] $end
    $var wire 32 C DATA_WIDTH [31:0] $end
    $var wire 32 E IMM_WIDTH [31:0] $end
    $var wire 32 4 ImmOp_o [31:0] $end
    $var wire  2 9 ImmSrc [1:0] $end
    $var wire  1 0 MemWrite_o $end
    $var wire  8 $ PC_i [7:0] $end
    $var wire  2 5 PCsrc_o [1:0] $end
    $var wire  1 / RegWrite_o $end
    $var wire  2 3 Resultsrc_o [1:0] $end
    $var wire  1 > Zero_i $end
    $var wire 32 # instr_o [31:0] $end
    $scope module ControlUnit $end
     $var wire  3 1 ALUctrl_o [2:0] $end
     $var wire  1 2 ALUsrc_o $end
     $var wire 32 D CONTROL_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire 32 E IMM_WIDTH [31:0] $end
     $var wire  2 9 ImmSrc_o [1:0] $end
     $var wire  1 0 MemWrite_o $end
     $var wire  2 5 PCsrc_o [1:0] $end
     $var wire  1 / RegWrite_o $end
     $var wire  2 3 Resultsrc_o [1:0] $end
     $var wire  1 > Zero_i $end
     $var wire  3 , funct3 [2:0] $end
     $var wire 32 # instr_i [31:0] $end
     $var wire  7 + opcode [6:0] $end
    $upscope $end
    $scope module InstrMem $end
     $var wire 32 B ADDRESS_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire 32 # Instr_o [31:0] $end
     $var wire  8 $ addr_i [7:0] $end
    $upscope $end
    $scope module MySignExtend $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire 32 E IMM_WIDTH [31:0] $end
     $var wire 32 4 ImmOp_o [31:0] $end
     $var wire  2 9 ImmSrc_i [1:0] $end
     $var wire 32 # instr_i [31:0] $end
    $upscope $end
   $upscope $end
   $scope module pc $end
    $var wire 32 6 ALUResult_i [31:0] $end
    $var wire 32 4 ImmOp_i [31:0] $end
    $var wire 32 . PC [31:0] $end
    $var wire 32 % PCPlus4_o [31:0] $end
    $var wire 32 A PCTarget [31:0] $end
    $var wire  2 5 PCsrc_i [1:0] $end
    $var wire 32 C WIDTH [31:0] $end
    $var wire  1 ; clk $end
    $var wire 32 : next_PC [31:0] $end
    $var wire 32 - pc_out [31:0] $end
    $var wire  1 < rst $end
    $scope module pc_mux $end
     $var wire 32 E CONTROL_WIDTH [31:0] $end
     $var wire 32 C DATA_WIDTH [31:0] $end
     $var wire  2 5 control [1:0] $end
     $var wire 32 % input0 [31:0] $end
     $var wire 32 A input1 [31:0] $end
     $var wire 32 6 input2 [31:0] $end
     $var wire 32 G input3 [31:0] $end
     $var wire 32 : out [31:0] $end
    $upscope $end
    $scope module pc_reg $end
     $var wire 32 C WIDTH [31:0] $end
     $var wire 32 - another_pc [31:0] $end
     $var wire  1 ; clk $end
     $var wire 32 : next_PC [31:0] $end
     $var wire 32 . pc [31:0] $end
     $var wire  1 < rst $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b00000000000000000000000000000000 #
b00000000 $
b00000000000000000000000000000100 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
b00000000 (
b00000000 )
b00000000 *
b0000000 +
b000 ,
b00000000000000000000000000000000 -
b00000000000000000000000000000000 .
0/
00
b000 1
02
b00 3
b00000000000000000000000000000000 4
b00 5
b00000000000000000000000000000000 6
b00000000000000000000000000000000 7
b00000000 8
b00 9
b00000000000000000000000000000000 :
0;
0<
b00000000000000000000000000000000 =
1>
b00000000000000000000000000000000 ?
b00000000000000000000000000000000 @
b00000000000000000000000000000000 A
b00000000000000000000000000001000 B
b00000000000000000000000000100000 C
b00000000000000000000000000000011 D
b00000000000000000000000000000010 E
b00000000000000000000000000000000 F
b00000000000000000000000000000000 G
#1
b00001111111100000000001100010011 #
b00011111 (
b00000110 *
b0010011 +
1/
12
b00000000000000000000000011111111 4
b00000000000000000000000011111111 6
b00000000000000000000000011111111 7
b11111111 8
b01 9
b00000000000000000000000000000100 :
1;
0>
b00000000000000000000000011111111 ?
b00000000000000000000000011111111 A
#2
0;
#3
b00000000000000000000010100010011 #
b00000100 $
b00000000000000000000000000001000 %
b00000000 (
b00001010 *
b00000000000000000000000000000100 -
b00000000000000000000000000000100 .
b00000000000000000000000000000000 4
b00000000000000000000000000000000 6
b00000000000000000000000000000000 7
b00000000 8
b00000000000000000000000000001000 :
1;
1>
b00000000000000000000000000000000 ?
b00000000000000000000000011111110 @
b00000000000000000000000000000100 A
#4
0;
#5
b00000000000000000000010110010011 #
b00001000 $
b00000000000000000000000000001100 %
b00001011 *
b00000000000000000000000000001000 -
b00000000000000000000000000001000 .
b00000000000000000000000000001100 :
1;
b00000000000000000000000000001000 A
#6
0;
#7
b00000000000001011000010100010011 #
b00001100 $
b00000000000000000000000000010000 %
b00001011 )
b00001010 *
b00000000000000000000000000001100 -
b00000000000000000000000000001100 .
b00000000000000000000000000010000 :
1;
b00000000000000000000000000001100 A
#8
0;
#9
b00000000000101011000010110010011 #
b00010000 $
b00000000000000000000000000010100 %
b00000001 (
b00001011 *
b00000000000000000000000000010000 -
b00000000000000000000000000010000 .
b00000000000000000000000000000001 4
b00000000000000000000000000000001 6
b00000000000000000000000000000001 7
b00000001 8
b00000000000000000000000000010100 :
1;
0>
b00000000000000000000000000000001 ?
b00000000000000000000000011111101 @
b00000000000000000000000000010001 A
#10
0;
#11
b11111110011001011001110011100011 #
b00010100 $
b00000000000000000000000000011000 %
b00000000000000000000000000000001 &
b00000000000000000000000011111111 '
b00000110 (
b00011001 *
b1100011 +
b001 ,
b00000000000000000000000000010100 -
b00000000000000000000000000010100 .
0/
02
b01 3
b11111111111111111111111111111000 4
b01 5
b00000000000000000000000100000000 6
b00000000000000000000000011111111 7
b00000000 8
b11 9
b00000000000000000000000000001100 :
1;
b00000000000000000000000011111110 ?
b00000000000000000000000011111110 @
b00000000000000000000000000001100 A
#12
0;
#13
b00000000000001011000010100010011 #
b00001100 $
b00000000000000000000000000010000 %
b00000000000000000000000000000000 '
b00000000 (
b00001010 *
b0010011 +
b000 ,
b00000000000000000000000000001100 -
b00000000000000000000000000001100 .
1/
12
b00 3
b00000000000000000000000000000000 4
b00 5
b00000000000000000000000000000001 6
b00000000000000000000000000000000 7
b00000001 8
b01 9
b00000000000000000000000000010000 :
1;
b00000000000000000000000000000001 ?
b00000000000000000000000011111101 @
#14
0;
#15
b00000000000101011000010110010011 #
b00010000 $
b00000000000000000000000000010100 %
b00000001 (
b00001011 *
b00000000000000000000000000010000 -
b00000000000000000000000000010000 .
b00000000000000000000000000000001 4
b00000000000000000000000000000010 6
b00000000000000000000000000000001 7
b00000010 8
b00000000000000000000000000010100 :
1;
b00000000000000000000000000000001 =
1>
b00000000000000000000000000000010 ?
b00000000000000000000000000010001 A
#16
0;
#17
b11111110011001011001110011100011 #
b00010100 $
b00000000000000000000000000011000 %
b00000000000000000000000000000010 &
b00000000000000000000000011111111 '
b00000110 (
b00011001 *
b1100011 +
b001 ,
b00000000000000000000000000010100 -
b00000000000000000000000000010100 .
0/
02
b01 3
b11111111111111111111111111111000 4
b01 5
b00000000000000000000000100000001 6
b00000000000000000000000011111111 7
b00000001 8
b11 9
b00000000000000000000000000001100 :
1;
0>
b00000000000000000000000011111101 ?
b00000000000000000000000000001100 A
#18
0;
#19
b00000000000001011000010100010011 #
b00001100 $
b00000000000000000000000000010000 %
b00000000000000000000000000000000 '
b00000000 (
b00001010 *
b0010011 +
b000 ,
b00000000000000000000000000001100 -
b00000000000000000000000000001100 .
1/
12
b00 3
b00000000000000000000000000000000 4
b00 5
b00000000000000000000000000000010 6
b00000000000000000000000000000000 7
b00000010 8
b01 9
b00000000000000000000000000010000 :
1;
b00000000000000000000000000000010 ?
